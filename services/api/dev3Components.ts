/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useDev3Context, Dev3Context } from "./dev3Context";
import type * as Fetcher from "./dev3Fetcher";
import { dev3Fetch } from "./dev3Fetcher";
import type * as Schemas from "./dev3Schemas";

export type ProjectControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type ProjectControllerCreateVariables = {
  body: Schemas.CreateProjectDto;
} & Dev3Context["fetcherOptions"];

export const fetchProjectControllerCreate = (
  variables: ProjectControllerCreateVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Project,
    ProjectControllerCreateError,
    Schemas.CreateProjectDto,
    {},
    {},
    {}
  >({ url: "/api/v1/project", method: "post", ...variables, signal });

export const useProjectControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Project,
      ProjectControllerCreateError,
      ProjectControllerCreateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Project,
    ProjectControllerCreateError,
    ProjectControllerCreateVariables
  >(
    (variables: ProjectControllerCreateVariables) =>
      fetchProjectControllerCreate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ProjectControllerFindAllQueryParams = {
  offset?: number;
  limit?: number;
  slug?: string;
  name?: string;
};

export type ProjectControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ProjectControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.Project[];
};

export type ProjectControllerFindAllVariables = {
  queryParams?: ProjectControllerFindAllQueryParams;
} & Dev3Context["fetcherOptions"];

export const fetchProjectControllerFindAll = (
  variables: ProjectControllerFindAllVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    ProjectControllerFindAllResponse,
    ProjectControllerFindAllError,
    undefined,
    {},
    ProjectControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/project", method: "get", ...variables, signal });

export const useProjectControllerFindAll = <
  TData = ProjectControllerFindAllResponse
>(
  variables: ProjectControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ProjectControllerFindAllResponse,
      ProjectControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    ProjectControllerFindAllResponse,
    ProjectControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/project",
      operationId: "projectControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchProjectControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ProjectControllerFindByIdPathParams = {
  id: string;
};

export type ProjectControllerFindByIdError = Fetcher.ErrorWrapper<undefined>;

export type ProjectControllerFindByIdVariables = {
  pathParams: ProjectControllerFindByIdPathParams;
} & Dev3Context["fetcherOptions"];

export const fetchProjectControllerFindById = (
  variables: ProjectControllerFindByIdVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Project,
    ProjectControllerFindByIdError,
    undefined,
    {},
    {},
    ProjectControllerFindByIdPathParams
  >({ url: "/api/v1/project/{id}", method: "get", ...variables, signal });

export const useProjectControllerFindById = <TData = Schemas.Project>(
  variables: ProjectControllerFindByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Project,
      ProjectControllerFindByIdError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    Schemas.Project,
    ProjectControllerFindByIdError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/project/{id}",
      operationId: "projectControllerFindById",
      variables,
    }),
    ({ signal }) =>
      fetchProjectControllerFindById(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ProjectControllerUpdatePathParams = {
  id: string;
};

export type ProjectControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type ProjectControllerUpdateVariables = {
  body?: Schemas.UpdateProjectDto;
  pathParams: ProjectControllerUpdatePathParams;
} & Dev3Context["fetcherOptions"];

export const fetchProjectControllerUpdate = (
  variables: ProjectControllerUpdateVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Project,
    ProjectControllerUpdateError,
    Schemas.UpdateProjectDto,
    {},
    {},
    ProjectControllerUpdatePathParams
  >({ url: "/api/v1/project/{id}", method: "patch", ...variables, signal });

export const useProjectControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Project,
      ProjectControllerUpdateError,
      ProjectControllerUpdateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Project,
    ProjectControllerUpdateError,
    ProjectControllerUpdateVariables
  >(
    (variables: ProjectControllerUpdateVariables) =>
      fetchProjectControllerUpdate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ProjectControllerFindBySlugPathParams = {
  slug: string;
};

export type ProjectControllerFindBySlugError = Fetcher.ErrorWrapper<undefined>;

export type ProjectControllerFindBySlugVariables = {
  pathParams: ProjectControllerFindBySlugPathParams;
} & Dev3Context["fetcherOptions"];

export const fetchProjectControllerFindBySlug = (
  variables: ProjectControllerFindBySlugVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Project,
    ProjectControllerFindBySlugError,
    undefined,
    {},
    {},
    ProjectControllerFindBySlugPathParams
  >({
    url: "/api/v1/project/slug/{slug}",
    method: "get",
    ...variables,
    signal,
  });

export const useProjectControllerFindBySlug = <TData = Schemas.Project>(
  variables: ProjectControllerFindBySlugVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Project,
      ProjectControllerFindBySlugError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    Schemas.Project,
    ProjectControllerFindBySlugError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/project/slug/{slug}",
      operationId: "projectControllerFindBySlug",
      variables,
    }),
    ({ signal }) =>
      fetchProjectControllerFindBySlug(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AuthControllerNearLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerNearLoginVariables = {
  body: Schemas.NearLoginRequestDto;
} & Dev3Context["fetcherOptions"];

export const fetchAuthControllerNearLogin = (
  variables: AuthControllerNearLoginVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.NearLoginResponseDto,
    AuthControllerNearLoginError,
    Schemas.NearLoginRequestDto,
    {},
    {},
    {}
  >({ url: "/api/v1/auth/near", method: "post", ...variables, signal });

export const useAuthControllerNearLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.NearLoginResponseDto,
      AuthControllerNearLoginError,
      AuthControllerNearLoginVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.NearLoginResponseDto,
    AuthControllerNearLoginError,
    AuthControllerNearLoginVariables
  >(
    (variables: AuthControllerNearLoginVariables) =>
      fetchAuthControllerNearLogin({ ...fetcherOptions, ...variables }),
    options
  );
};

export type UserControllerFindMeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerFindMeVariables = Dev3Context["fetcherOptions"];

export const fetchUserControllerFindMe = (
  variables: UserControllerFindMeVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<Schemas.User, UserControllerFindMeError, undefined, {}, {}, {}>({
    url: "/api/v1/user/me",
    method: "get",
    ...variables,
    signal,
  });

export const useUserControllerFindMe = <TData = Schemas.User>(
  variables: UserControllerFindMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, UserControllerFindMeError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<Schemas.User, UserControllerFindMeError, TData>(
    queryKeyFn({
      path: "/api/v1/user/me",
      operationId: "userControllerFindMe",
      variables,
    }),
    ({ signal }) =>
      fetchUserControllerFindMe({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AddressControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type AddressControllerCreateVariables = {
  body: Schemas.CreateAddressDto;
} & Dev3Context["fetcherOptions"];

export const fetchAddressControllerCreate = (
  variables: AddressControllerCreateVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Address,
    AddressControllerCreateError,
    Schemas.CreateAddressDto,
    {},
    {},
    {}
  >({ url: "/api/v1/address", method: "post", ...variables, signal });

export const useAddressControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Address,
      AddressControllerCreateError,
      AddressControllerCreateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Address,
    AddressControllerCreateError,
    AddressControllerCreateVariables
  >(
    (variables: AddressControllerCreateVariables) =>
      fetchAddressControllerCreate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type AddressControllerFindAllQueryParams = {
  offset?: number;
  limit?: number;
  alias?: string;
};

export type AddressControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type AddressControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.Address[];
};

export type AddressControllerFindAllVariables = {
  queryParams?: AddressControllerFindAllQueryParams;
} & Dev3Context["fetcherOptions"];

export const fetchAddressControllerFindAll = (
  variables: AddressControllerFindAllVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    AddressControllerFindAllResponse,
    AddressControllerFindAllError,
    undefined,
    {},
    AddressControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/address", method: "get", ...variables, signal });

export const useAddressControllerFindAll = <
  TData = AddressControllerFindAllResponse
>(
  variables: AddressControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AddressControllerFindAllResponse,
      AddressControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    AddressControllerFindAllResponse,
    AddressControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/address",
      operationId: "addressControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchAddressControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AddressControllerFindOnePathParams = {
  id: string;
};

export type AddressControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type AddressControllerFindOneVariables = {
  pathParams: AddressControllerFindOnePathParams;
} & Dev3Context["fetcherOptions"];

export const fetchAddressControllerFindOne = (
  variables: AddressControllerFindOneVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Address,
    AddressControllerFindOneError,
    undefined,
    {},
    {},
    AddressControllerFindOnePathParams
  >({ url: "/api/v1/address/{id}", method: "get", ...variables, signal });

export const useAddressControllerFindOne = <TData = Schemas.Address>(
  variables: AddressControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Address,
      AddressControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    Schemas.Address,
    AddressControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/address/{id}",
      operationId: "addressControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchAddressControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type AddressControllerUpdatePathParams = {
  id: string;
};

export type AddressControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type AddressControllerUpdateVariables = {
  body?: Schemas.UpdateAddressDto;
  pathParams: AddressControllerUpdatePathParams;
} & Dev3Context["fetcherOptions"];

export const fetchAddressControllerUpdate = (
  variables: AddressControllerUpdateVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Address,
    AddressControllerUpdateError,
    Schemas.UpdateAddressDto,
    {},
    {},
    AddressControllerUpdatePathParams
  >({ url: "/api/v1/address/{id}", method: "patch", ...variables, signal });

export const useAddressControllerUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Address,
      AddressControllerUpdateError,
      AddressControllerUpdateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Address,
    AddressControllerUpdateError,
    AddressControllerUpdateVariables
  >(
    (variables: AddressControllerUpdateVariables) =>
      fetchAddressControllerUpdate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type AddressControllerRemovePathParams = {
  id: string;
};

export type AddressControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type AddressControllerRemoveVariables = {
  pathParams: AddressControllerRemovePathParams;
} & Dev3Context["fetcherOptions"];

export const fetchAddressControllerRemove = (
  variables: AddressControllerRemoveVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Address,
    AddressControllerRemoveError,
    undefined,
    {},
    {},
    AddressControllerRemovePathParams
  >({ url: "/api/v1/address/{id}", method: "delete", ...variables, signal });

export const useAddressControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Address,
      AddressControllerRemoveError,
      AddressControllerRemoveVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Address,
    AddressControllerRemoveError,
    AddressControllerRemoveVariables
  >(
    (variables: AddressControllerRemoveVariables) =>
      fetchAddressControllerRemove({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PaymentControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type PaymentControllerCreateVariables = {
  body: Schemas.CreatePaymentDto;
} & Dev3Context["fetcherOptions"];

export const fetchPaymentControllerCreate = (
  variables: PaymentControllerCreateVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.Payment,
    PaymentControllerCreateError,
    Schemas.CreatePaymentDto,
    {},
    {},
    {}
  >({ url: "/api/v1/payment", method: "post", ...variables, signal });

export const usePaymentControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Payment,
      PaymentControllerCreateError,
      PaymentControllerCreateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.Payment,
    PaymentControllerCreateError,
    PaymentControllerCreateVariables
  >(
    (variables: PaymentControllerCreateVariables) =>
      fetchPaymentControllerCreate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PaymentControllerFindAllQueryParams = {
  offset?: number;
  limit?: number;
  uid?: string;
  receiver?: string;
  receiver_fungible?: string;
  status?: "pending" | "paid";
};

export type PaymentControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type PaymentControllerFindAllResponse = Schemas.PaginatedDto & {
  results?: Schemas.Payment[];
};

export type PaymentControllerFindAllVariables = {
  queryParams?: PaymentControllerFindAllQueryParams;
} & Dev3Context["fetcherOptions"];

export const fetchPaymentControllerFindAll = (
  variables: PaymentControllerFindAllVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    PaymentControllerFindAllResponse,
    PaymentControllerFindAllError,
    undefined,
    {},
    PaymentControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/payment", method: "get", ...variables, signal });

export const usePaymentControllerFindAll = <
  TData = PaymentControllerFindAllResponse
>(
  variables: PaymentControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PaymentControllerFindAllResponse,
      PaymentControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    PaymentControllerFindAllResponse,
    PaymentControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/payment",
      operationId: "paymentControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchPaymentControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PaymentControllerFindByIdPathParams = {
  id: string;
};

export type PaymentControllerFindByIdError = Fetcher.ErrorWrapper<undefined>;

export type PaymentControllerFindByIdVariables = {
  pathParams: PaymentControllerFindByIdPathParams;
} & Dev3Context["fetcherOptions"];

export const fetchPaymentControllerFindById = (
  variables: PaymentControllerFindByIdVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.PaymentDto,
    PaymentControllerFindByIdError,
    undefined,
    {},
    {},
    PaymentControllerFindByIdPathParams
  >({ url: "/api/v1/payment/{id}", method: "get", ...variables, signal });

export const usePaymentControllerFindById = <TData = Schemas.PaymentDto>(
  variables: PaymentControllerFindByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaymentDto,
      PaymentControllerFindByIdError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useDev3Context(options);
  return reactQuery.useQuery<
    Schemas.PaymentDto,
    PaymentControllerFindByIdError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/payment/{id}",
      operationId: "paymentControllerFindById",
      variables,
    }),
    ({ signal }) =>
      fetchPaymentControllerFindById(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PaymentControllerPagodaEventError = Fetcher.ErrorWrapper<undefined>;

export type PaymentControllerPagodaEventVariables =
  Dev3Context["fetcherOptions"];

export const fetchPaymentControllerPagodaEvent = (
  variables: PaymentControllerPagodaEventVariables,
  signal?: AbortSignal
) =>
  dev3Fetch<
    Schemas.PaymentDto,
    PaymentControllerPagodaEventError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1/payment/ft-transfer-pagoda",
    method: "post",
    ...variables,
    signal,
  });

export const usePaymentControllerPagodaEvent = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaymentDto,
      PaymentControllerPagodaEventError,
      PaymentControllerPagodaEventVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useDev3Context();
  return reactQuery.useMutation<
    Schemas.PaymentDto,
    PaymentControllerPagodaEventError,
    PaymentControllerPagodaEventVariables
  >(
    (variables: PaymentControllerPagodaEventVariables) =>
      fetchPaymentControllerPagodaEvent({ ...fetcherOptions, ...variables }),
    options
  );
};

export type QueryOperation =
  | {
      path: "/api/v1/project";
      operationId: "projectControllerFindAll";
      variables: ProjectControllerFindAllVariables;
    }
  | {
      path: "/api/v1/project/{id}";
      operationId: "projectControllerFindById";
      variables: ProjectControllerFindByIdVariables;
    }
  | {
      path: "/api/v1/project/slug/{slug}";
      operationId: "projectControllerFindBySlug";
      variables: ProjectControllerFindBySlugVariables;
    }
  | {
      path: "/api/v1/user/me";
      operationId: "userControllerFindMe";
      variables: UserControllerFindMeVariables;
    }
  | {
      path: "/api/v1/address";
      operationId: "addressControllerFindAll";
      variables: AddressControllerFindAllVariables;
    }
  | {
      path: "/api/v1/address/{id}";
      operationId: "addressControllerFindOne";
      variables: AddressControllerFindOneVariables;
    }
  | {
      path: "/api/v1/payment";
      operationId: "paymentControllerFindAll";
      variables: PaymentControllerFindAllVariables;
    }
  | {
      path: "/api/v1/payment/{id}";
      operationId: "paymentControllerFindById";
      variables: PaymentControllerFindByIdVariables;
    };
